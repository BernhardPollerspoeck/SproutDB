using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Buffers;

namespace SpoutDB.Parsing
{
    // AST Node Interfaces and Base Types
    public interface IStatement
    {
        StatementType Type { get; }
        int Position { get; }
    }

    public enum StatementType
    {
        Query,
        Upsert,
        Delete,
        Schema,
        Branch,
        Auth,
        Meta
    }

    // Expression discriminated union to avoid boxing
    public readonly struct Expression
    {
        public ExpressionType Type { get; }
        public int Position { get; }
        private readonly object _value;

        private Expression(ExpressionType type, int position, object value)
        {
            Type = type;
            Position = position;
            _value = value;
        }

        public T As<T>() => (T)_value;

        public static Expression FieldPath(int position, ReadOnlyMemory<string> segments) 
            => new(ExpressionType.FieldPath, position, segments);
        
        public static Expression Binary(int position, LogicalOperator op, Expression left, Expression right)
            => new(ExpressionType.Binary, position, new BinaryData(op, left, right));
        
        public static Expression Comparison(int position, ComparisonOperator op, Expression left, Expression right)
            => new(ExpressionType.Comparison, position, new ComparisonData(op, left, right));
        
        public static Expression Literal(int position, LiteralType literalType, string value)
            => new(ExpressionType.Literal, position, new LiteralData(literalType, value));
        
        public static Expression JsonValue(int position, JsonValueType valueType, object value)
            => new(ExpressionType.JsonValue, position, new JsonData(valueType, value));

        // Helper structs for typed data
        public readonly struct BinaryData
        {
            public LogicalOperator Operator { get; }
            public Expression Left { get; }
            public Expression Right { get; }

            public BinaryData(LogicalOperator op, Expression left, Expression right)
            {
                Operator = op;
                Left = left;
                Right = right;
            }
        }

        public readonly struct ComparisonData
        {
            public ComparisonOperator Operator { get; }
            public Expression Left { get; }
            public Expression Right { get; }

            public ComparisonData(ComparisonOperator op, Expression left, Expression right)
            {
                Operator = op;
                Left = left;
                Right = right;
            }
        }

        public readonly struct LiteralData
        {
            public LiteralType LiteralType { get; }
            public string Value { get; }

            public LiteralData(LiteralType literalType, string value)
            {
                LiteralType = literalType;
                Value = value;
            }
        }

        public readonly struct JsonData
        {
            public JsonValueType ValueType { get; }
            public object Value { get; }

            public JsonData(JsonValueType valueType, object value)
            {
                ValueType = valueType;
                Value = value;
            }
        }
    }

    public enum ExpressionType
    {
        FieldPath,
        Binary,
        Comparison,
        Literal,
        JsonValue
    }

    // Core AST Nodes - All structs for performance
    public readonly struct QueryStatement : IStatement
    {
        public StatementType Type => StatementType.Query;
        public int Position { get; }
        public QueryOperation Operation { get; }
        public TableExpression Table { get; }
        public ReadOnlyMemory<JoinExpression> Joins { get; }
        public Expression? Where { get; }
        public ReadOnlyMemory<Expression> GroupBy { get; }
        public Expression? Having { get; }
        public ReadOnlyMemory<OrderByField> OrderBy { get; }
        public ReadOnlyMemory<Expression> Select { get; }
        public PaginationExpression? Pagination { get; }

        public QueryStatement(int position, QueryOperation operation, TableExpression table,
            ReadOnlyMemory<JoinExpression> joins = default,
            Expression? where = null,
            ReadOnlyMemory<Expression> groupBy = default,
            Expression? having = null,
            ReadOnlyMemory<OrderByField> orderBy = default,
            ReadOnlyMemory<Expression> select = default,
            PaginationExpression? pagination = null)
        {
            Position = position;
            Operation = operation;
            Table = table;
            Joins = joins;
            Where = where;
            GroupBy = groupBy;
            Having = having;
            OrderBy = orderBy;
            Select = select;
            Pagination = pagination;
        }
    }

    public readonly struct UpsertStatement : IStatement
    {
        public StatementType Type => StatementType.Upsert;
        public int Position { get; }
        public TableExpression Table { get; }
        public Expression Data { get; }
        public string? OnField { get; }

        public UpsertStatement(int position, TableExpression table, Expression data, string? onField = null)
        {
            Position = position;
            Table = table;
            Data = data;
            OnField = onField;
        }
    }

    public readonly struct DeleteStatement : IStatement
    {
        public StatementType Type => StatementType.Delete;
        public int Position { get; }
        public TableExpression Table { get; }
        public Expression? Where { get; }

        public DeleteStatement(int position, TableExpression table, Expression? where = null)
        {
            Position = position;
            Table = table;
            Where = where;
        }
    }

    public readonly struct SchemaStatement : IStatement
    {
        public StatementType Type => StatementType.Schema;
        public int Position { get; }
        public SchemaOperation Operation { get; }
        public string? TableName { get; }
        public string? ColumnName { get; }
        public string? DataType { get; }

        public SchemaStatement(int position, SchemaOperation operation, string? tableName = null, 
            string? columnName = null, string? dataType = null)
        {
            Position = position;
            Operation = operation;
            TableName = tableName;
            ColumnName = columnName;
            DataType = dataType;
        }
    }

    public readonly struct BranchStatement : IStatement
    {
        public StatementType Type => StatementType.Branch;
        public int Position { get; }
        public BranchOperation Operation { get; }
        public string? BranchName { get; }
        public string? SourceBranch { get; }
        public string? TargetBranch { get; }
        public string? AsOfTime { get; }
        public string? Alias { get; }

        public BranchStatement(int position, BranchOperation operation, string? branchName = null,
            string? sourceBranch = null, string? targetBranch = null, string? asOfTime = null, string? alias = null)
        {
            Position = position;
            Operation = operation;
            BranchName = branchName;
            SourceBranch = sourceBranch;
            TargetBranch = targetBranch;
            AsOfTime = asOfTime;
            Alias = alias;
        }
    }

    public readonly struct AuthStatement : IStatement
    {
        public StatementType Type => StatementType.Auth;
        public int Position { get; }
        public AuthOperation Operation { get; }
        public string? TokenName { get; }
        public Expression? Configuration { get; }

        public AuthStatement(int position, AuthOperation operation, string? tokenName = null, Expression? configuration = null)
        {
            Position = position;
            Operation = operation;
            TokenName = tokenName;
            Configuration = configuration;
        }
    }

    public readonly struct MetaStatement : IStatement
    {
        public StatementType Type => StatementType.Meta;
        public int Position { get; }
        public MetaOperation Operation { get; }
        public string? Target { get; }
        public string? Source { get; }

        public MetaStatement(int position, MetaOperation operation, string? target = null, string? source = null)
        {
            Position = position;
            Operation = operation;
            Target = target;
            Source = source;
        }
    }

    // Helper Types
    public readonly struct TableExpression
    {
        public int Position { get; }
        public string Name { get; }
        public string? Alias { get; }

        public TableExpression(int position, string name, string? alias = null)
        {
            Position = position;
            Name = name;
            Alias = alias;
        }
    }

    public readonly struct JoinExpression
    {
        public int Position { get; }
        public Expression LeftPath { get; }
        public Expression RightPath { get; }
        public string Alias { get; }
        public JoinType JoinType { get; }

        public JoinExpression(int position, Expression leftPath, Expression rightPath, 
            string alias, JoinType joinType = JoinType.Inner)
        {
            Position = position;
            LeftPath = leftPath;
            RightPath = rightPath;
            Alias = alias;
            JoinType = joinType;
        }
    }

    public readonly struct OrderByField
    {
        public Expression Field { get; }
        public SortDirection Direction { get; }

        public OrderByField(Expression field, SortDirection direction = SortDirection.Asc)
        {
            Field = field;
            Direction = direction;
        }
    }

    public readonly struct PaginationExpression
    {
        public int Position { get; }
        public int Page { get; }
        public int Size { get; }

        public PaginationExpression(int position, int page, int size)
        {
            Position = position;
            Page = page;
            Size = size;
        }
    }

    // Enums
    public enum QueryOperation
    {
        Get,
        Count,
        Sum,
        Avg
    }

    public enum SchemaOperation
    {
        CreateTable,
        DropTable,
        AddColumn,
        PurgeColumn
    }

    public enum BranchOperation
    {
        Create,
        Checkout,
        Merge,
        Delete,
        Protect,
        Unprotect,
        Abandon,
        Reactivate
    }

    public enum AuthOperation
    {
        CreateToken,
        UpdateToken,
        RevokeToken,
        ListTokens,
        DisableToken,
        EnableToken
    }

    public enum MetaOperation
    {
        Backup,
        Restore,
        Explain,
        Respawn
    }

    public enum JoinType
    {
        Inner,
        Left,
        Right
    }

    public enum LogicalOperator
    {
        And,
        Or,
        Not
    }

    public enum ComparisonOperator
    {
        Equals,
        NotEquals,
        GreaterThan,
        GreaterThanOrEqual,
        LessThan,
        LessThanOrEqual,
        In,
        Contains,
        Any
    }

    public enum LiteralType
    {
        String,
        Number,
        Boolean,
        Null,
        Date
    }

    public enum JsonValueType
    {
        Object,
        Array,
        String,
        Number,
        Boolean,
        Null
    }

    public enum SortDirection
    {
        Asc,
        Desc
    }

    // Production-Ready Parser Implementation
    public ref struct Parser
    {
        private readonly ReadOnlySpan<Token> _tokens;
        private int _position;
        private readonly ArrayPool<string> _stringPool;
        private readonly ArrayPool<JoinExpression> _joinPool;
        private readonly ArrayPool<Expression> _expressionPool;
        private readonly ArrayPool<OrderByField> _orderByPool;

        public Parser(ReadOnlySpan<Token> tokens)
        {
            _tokens = tokens;
            _position = 0;
            _stringPool = ArrayPool<string>.Shared;
            _joinPool = ArrayPool<JoinExpression>.Shared;
            _expressionPool = ArrayPool<Expression>.Shared;
            _orderByPool = ArrayPool<OrderByField>.Shared;
        }

        public Parser(TokenEnumerator tokenEnumerator) : this(CollectTokens(tokenEnumerator))
        {
        }

        private static ReadOnlySpan<Token> CollectTokens(TokenEnumerator tokenEnumerator)
        {
            var tokens = new List<Token>();
            while (tokenEnumerator.MoveNext())
            {
                tokens.Add(tokenEnumerator.Current);
            }
            tokens.Add(new Token(TokenType.EOF, string.Empty, tokens.Count > 0 ? tokens[^1].Position + tokens[^1].Length : 0));
            return tokens.ToArray();
        }

        private Token Current => _position < _tokens.Length ? _tokens[_position] : _tokens[^1]; // EOF token
        private Token Peek(int offset = 1) => (_position + offset) < _tokens.Length ? _tokens[_position + offset] : _tokens[^1];

        public IStatement Parse()
        {
            if (_tokens.Length == 0 || (_tokens.Length == 1 && _tokens[0].Type == TokenType.EOF))
                throw new ParseException("Empty input", 0);

            return ParseStatement();
        }

        private IStatement ParseStatement()
        {
            return Current.Type switch
            {
                TokenType.Get or TokenType.Count or TokenType.Sum or TokenType.Avg => ParseQueryStatement(),
                TokenType.Upsert => ParseUpsertStatement(),
                TokenType.Delete => ParseDeleteStatement(),
                TokenType.Create => ParseCreateStatement(),
                TokenType.Add => ParseAddStatement(),
                TokenType.Purge => ParsePurgeStatement(),
                TokenType.Drop => ParseDropStatement(),
                TokenType.Update => ParseUpdateStatement(),
                TokenType.Checkout => ParseCheckoutStatement(),
                TokenType.Merge => ParseMergeStatement(),
                TokenType.Protect or TokenType.Unprotect or TokenType.Abandon or TokenType.Reactivate => ParseBranchManagementStatement(),
                TokenType.Revoke or TokenType.Disable or TokenType.Enable or TokenType.List => ParseAuthStatement(),
                TokenType.Backup or TokenType.Restore or TokenType.Explain or TokenType.Respawn => ParseMetaStatement(),
                TokenType.EOF => throw new ParseException("Unexpected end of input", Current.Position),
                _ => throw new ParseException($"Unexpected token '{Current.Value}'", Current.Position)
            };
        }

        private QueryStatement ParseQueryStatement()
        {
            var position = Current.Position;
            var operation = Current.Type switch
            {
                TokenType.Get => QueryOperation.Get,
                TokenType.Count => QueryOperation.Count,
                TokenType.Sum => QueryOperation.Sum,
                TokenType.Avg => QueryOperation.Avg,
                _ => throw new ParseException($"Expected query operation", Current.Position)
            };

            Advance();

            var table = ParseTableExpression();
            var joins = ParseJoinClauses();
            var where = ParseOptionalWhereClause();
            var groupBy = ParseOptionalGroupByClause();
            var having = ParseOptionalHavingClause();
            var orderBy = ParseOptionalOrderByClause();
            var select = ParseOptionalSelectClause();
            var pagination = ParseOptionalPaginationClause();

            return new QueryStatement(position, operation, table, joins, where, groupBy, having, orderBy, select, pagination);
        }

        private UpsertStatement ParseUpsertStatement()
        {
            var position = Current.Position;
            Expect(TokenType.Upsert);

            var table = ParseTableExpression();
            var data = ParseJsonExpression();
            string? onField = null;

            if (Current.Type == TokenType.On)
            {
                Advance();
                onField = ExpectIdentifier();
            }

            return new UpsertStatement(position, table, data, onField);
        }

        private DeleteStatement ParseDeleteStatement()
        {
            var position = Current.Position;
            Expect(TokenType.Delete);

            var table = ParseTableExpression();
            var where = ParseOptionalWhereClause();

            return new DeleteStatement(position, table, where);
        }

        private IStatement ParseCreateStatement()
        {
            var position = Current.Position;
            Expect(TokenType.Create);

            return Current.Type switch
            {
                TokenType.Table => ParseCreateTableStatement(position),
                TokenType.Branch => ParseCreateBranchStatement(position),
                TokenType.Alias => ParseCreateAliasStatement(position),
                TokenType.Token => ParseCreateTokenStatement(position),
                _ => throw new ParseException($"Expected 'table', 'branch', 'alias', or 'token' after 'create'", Current.Position)
            };
        }

        private SchemaStatement ParseCreateTableStatement(int position)
        {
            Expect(TokenType.Table);
            var tableName = ExpectIdentifier();
            return new SchemaStatement(position, SchemaOperation.CreateTable, tableName);
        }

        private BranchStatement ParseCreateBranchStatement(int position)
        {
            Expect(TokenType.Branch);
            var branchName = ExpectIdentifier();
            
            string? sourceBranch = null;
            if (Current.Type == TokenType.From)
            {
                Advance();
                sourceBranch = ExpectIdentifier();
            }

            return new BranchStatement(position, BranchOperation.Create, branchName, sourceBranch);
        }

        private BranchStatement ParseCreateAliasStatement(int position)
        {
            Expect(TokenType.Alias);
            var aliasName = ExpectIdentifier();
            
            if (Current.Type == TokenType.For)
            {
                throw new ParseException("'for' keyword not supported in tokenizer - use different syntax", Current.Position);
            }
            
            // Simplified: create alias name branch target
            Expect(TokenType.Branch);
            var targetBranch = ExpectIdentifier();

            return new BranchStatement(position, BranchOperation.Create, aliasName, targetBranch);
        }

        private AuthStatement ParseCreateTokenStatement(int position)
        {
            Expect(TokenType.Token);
            var tokenName = ExpectString();
            
            Expression? config = null;
            if (Current.Type == TokenType.With)
            {
                Advance();
                config = ParseJsonExpression();
            }

            return new AuthStatement(position, AuthOperation.CreateToken, tokenName, config);
        }

        private SchemaStatement ParseAddStatement()
        {
            var position = Current.Position;
            Expect(TokenType.Add);
            Expect(TokenType.Column);

            var fieldPath = ParseFieldPath();
            var segments = fieldPath.As<ReadOnlyMemory<string>>().Span;
            
            if (segments.Length != 2)
                throw new ParseException("Expected table.column format", fieldPath.Position);

            var tableName = segments[0];
            var columnName = segments[1];
            
            string? dataType = null;
            if (Current.Type == TokenType.Identifier)
            {
                dataType = Current.Value;
                Advance();
            }

            return new SchemaStatement(position, SchemaOperation.AddColumn, tableName, columnName, dataType);
        }

        private SchemaStatement ParsePurgeStatement()
        {
            var position = Current.Position;
            Expect(TokenType.Purge);
            Expect(TokenType.Column);

            var fieldPath = ParseFieldPath();
            var segments = fieldPath.As<ReadOnlyMemory<string>>().Span;
            
            if (segments.Length != 2)
                throw new ParseException("Expected table.column format", fieldPath.Position);

            var tableName = segments[0];
            var columnName = segments[1];

            return new SchemaStatement(position, SchemaOperation.PurgeColumn, tableName, columnName);
        }

        private SchemaStatement ParseDropStatement()
        {
            var position = Current.Position;
            Expect(TokenType.Drop);
            Expect(TokenType.Table);

            var tableName = ExpectIdentifier();
            return new SchemaStatement(position, SchemaOperation.DropTable, tableName);
        }

        private BranchStatement ParseUpdateStatement()
        {
            var position = Current.Position;
            Expect(TokenType.Update);
            Expect(TokenType.Alias);
            
            var aliasName = ExpectIdentifier();
            // Simplified: update alias name branch target
            Expect(TokenType.Branch);
            var targetBranch = ExpectIdentifier();

            return new BranchStatement(position, BranchOperation.Create, aliasName, targetBranch); // Reuse Create with different context
        }

        private BranchStatement ParseCheckoutStatement()
        {
            var position = Current.Position;
            Expect(TokenType.Checkout);
            Expect(TokenType.Branch);

            var branchName = ExpectIdentifier();
            string? asOfTime = null;
            string? alias = null;

            if (Current.Type == TokenType.As && Peek().Type == TokenType.Of)
            {
                Advance(); // 'as'
                Advance(); // 'of'
                asOfTime = ExpectString();
                
                if (Current.Type == TokenType.As)
                {
                    Advance();
                    alias = ExpectIdentifier();
                }
            }

            return new BranchStatement(position, BranchOperation.Checkout, branchName, asOfTime: asOfTime, alias: alias);
        }

        private BranchStatement ParseMergeStatement()
        {
            var position = Current.Position;
            Expect(TokenType.Merge);

            var sourceBranch = ExpectIdentifier();
            Expect(TokenType.Into);
            var targetBranch = ExpectIdentifier();

            return new BranchStatement(position, BranchOperation.Merge, sourceBranch: sourceBranch, targetBranch: targetBranch);
        }

        private BranchStatement ParseBranchManagementStatement()
        {
            var position = Current.Position;
            var operation = Current.Type switch
            {
                TokenType.Protect => BranchOperation.Protect,
                TokenType.Unprotect => BranchOperation.Unprotect,
                TokenType.Abandon => BranchOperation.Abandon,
                TokenType.Reactivate => BranchOperation.Reactivate,
                _ => throw new ParseException($"Unexpected branch operation", Current.Position)
            };

            Advance();
            Expect(TokenType.Branch);
            var branchName = ExpectIdentifier();

            return new BranchStatement(position, operation, branchName);
        }

        private AuthStatement ParseAuthStatement()
        {
            var position = Current.Position;
            var operation = Current.Type switch
            {
                TokenType.Revoke => AuthOperation.RevokeToken,
                TokenType.Disable => AuthOperation.DisableToken,
                TokenType.Enable => AuthOperation.EnableToken,
                TokenType.List => AuthOperation.ListTokens,
                _ => throw new ParseException($"Unexpected auth operation", Current.Position)
            };

            Advance();

            string? tokenName = null;
            if (operation != AuthOperation.ListTokens)
            {
                Expect(TokenType.Token);
                tokenName = ExpectString();
            }
            else if (Current.Type == TokenType.Token) // list tokens
            {
                Advance(); // consume 'token'
            }

            return new AuthStatement(position, operation, tokenName);
        }

        private MetaStatement ParseMetaStatement()
        {
            var position = Current.Position;
            var operation = Current.Type switch
            {
                TokenType.Backup => MetaOperation.Backup,
                TokenType.Restore => MetaOperation.Restore,
                TokenType.Explain => MetaOperation.Explain,
                TokenType.Respawn => MetaOperation.Respawn,
                _ => throw new ParseException($"Unexpected meta operation", Current.Position)
            };

            Advance();

            string? target = null;
            string? source = null;

            switch (operation)
            {
                case MetaOperation.Backup:
                    // backup database to "file.db"
                    if (Current.Type == TokenType.Identifier && Current.Value.ToLowerInvariant() == "database")
                        Advance();
                    if (Current.Type == TokenType.Identifier && Current.Value.ToLowerInvariant() == "to")
                        Advance();
                    target = ExpectString();
                    break;

                case MetaOperation.Restore:
                    // restore database from "file.db"
                    if (Current.Type == TokenType.Identifier && Current.Value.ToLowerInvariant() == "database")
                        Advance();
                    if (Current.Type == TokenType.From)
                        Advance();
                    source = ExpectString();
                    break;

                case MetaOperation.Explain:
                    // explain get users where...
                    target = "query"; // The rest is another statement, but simplified for now
                    break;

                case MetaOperation.Respawn:
                    // respawn branch name as new-db
                    Expect(TokenType.Branch);
                    source = ExpectIdentifier();
                    if (Current.Type == TokenType.As)
                    {
                        Advance();
                        target = ExpectIdentifier();
                    }
                    break;
            }

            return new MetaStatement(position, operation, target, source);
        }

        private TableExpression ParseTableExpression()
        {
            var position = Current.Position;
            var name = ExpectIdentifier();
            
            string? alias = null;
            if (Current.Type == TokenType.As)
            {
                Advance();
                alias = ExpectIdentifier();
            }

            return new TableExpression(position, name, alias);
        }

        private ReadOnlyMemory<JoinExpression> ParseJoinClauses()
        {
            if (Current.Type != TokenType.Follow)
                return ReadOnlyMemory<JoinExpression>.Empty;

            var joins = new List<JoinExpression>();

            while (Current.Type == TokenType.Follow)
            {
                joins.Add(ParseJoinExpression());
            }

            return joins.ToArray();
        }

        private JoinExpression ParseJoinExpression()
        {
            var position = Current.Position;
            Expect(TokenType.Follow);

            var leftPath = ParseFieldPath();
            Expect(TokenType.Arrow);
            var rightPath = ParseFieldPath();
            Expect(TokenType.As);
            var alias = ExpectIdentifier();

            var joinType = JoinType.Inner;
            if (Current.Type == TokenType.LeftParen)
            {
                Advance();
                joinType = Current.Type switch
                {
                    TokenType.Left => JoinType.Left,
                    TokenType.Inner => JoinType.Inner,
                    TokenType.Right => JoinType.Right,
                    _ => throw new ParseException($"Expected join type", Current.Position)
                };
                Advance();
                Expect(TokenType.RightParen);
            }

            return new JoinExpression(position, leftPath, rightPath, alias, joinType);
        }

        private Expression ParseFieldPath()
        {
            var position = Current.Position;
            var segments = new List<string>();

            segments.Add(ExpectIdentifier());

            while (Current.Type == TokenType.Dot)
            {
                Advance();
                segments.Add(ExpectIdentifier());
            }

            return Expression.FieldPath(position, segments.ToArray());
        }

        private Expression? ParseOptionalWhereClause()
        {
            if (Current.Type != TokenType.Where)
                return null;

            Advance();
            return ParseOrExpression();
        }

        private Expression ParseOrExpression()
        {
            var left = ParseAndExpression();

            while (Current.Type == TokenType.Or)
            {
                var position = Current.Position;
                Advance();
                var right = ParseAndExpression();
                left = Expression.Binary(position, LogicalOperator.Or, left, right);
            }

            return left;
        }

        private Expression ParseAndExpression()
        {
            var left = ParseComparisonExpression();

            while (Current.Type == TokenType.And)
            {
                var position = Current.Position;
                Advance();
                var right = ParseComparisonExpression();
                left = Expression.Binary(position, LogicalOperator.And, left, right);
            }

            return left;
        }

        private Expression ParseComparisonExpression()
        {
            var left = ParsePrimaryExpression();

            if (IsComparisonOperator(Current.Type))
            {
                var position = Current.Position;
                var op = TokenTypeToComparisonOperator(Current.Type);
                Advance();
                var right = ParsePrimaryExpression();
                return Expression.Comparison(position, op, left, right);
            }

            return left;
        }

        private Expression ParsePrimaryExpression()
        {
            return Current.Type switch
            {
                TokenType.Identifier => ParseFieldPath(),
                TokenType.String => ParseStringLiteral(),
                TokenType.Number => ParseNumberLiteral(),
                TokenType.Boolean => ParseBooleanLiteral(),
                TokenType.Null => ParseNullLiteral(),
                TokenType.LeftBracket => ParseArrayLiteral(),
                TokenType.LeftParen => ParseParenthesizedExpression(),
                _ => throw new ParseException($"Unexpected token in expression: '{Current.Value}'", Current.Position)
            };
        }

        private Expression ParseStringLiteral()
        {
            var position = Current.Position;
            var value = Current.Value;
            Advance();
            return Expression.Literal(position, LiteralType.String, value);
        }

        private Expression ParseNumberLiteral()
        {
            var position = Current.Position;
            var value = Current.Value;
            Advance();
            return Expression.Literal(position, LiteralType.Number, value);
        }

        private Expression ParseBooleanLiteral()
        {
            var position = Current.Position;
            var value = Current.Value;
            Advance();
            return Expression.Literal(position, LiteralType.Boolean, value);
        }

        private Expression ParseNullLiteral()
        {
            var position = Current.Position;
            Advance();
            return Expression.Literal(position, LiteralType.Null, "null");
        }

        private Expression ParseArrayLiteral()
        {
            var position = Current.Position;
            Expect(TokenType.LeftBracket);

            var items = new List<Expression>();

            while (Current.Type != TokenType.RightBracket)
            {
                items.Add(ParseJsonValue());

                if (Current.Type == TokenType.Comma)
                    Advance();
                else
                    break;
            }

            Expect(TokenType.RightBracket);
            return Expression.JsonValue(position, JsonValueType.Array, items.ToArray());
        }

        private Expression ParseParenthesizedExpression()
        {
            Expect(TokenType.LeftParen);
            var expression = ParseOrExpression();
            Expect(TokenType.RightParen);
            return expression;
        }

        private Expression ParseJsonExpression()
        {
            return Current.Type switch
            {
                TokenType.LeftBrace => ParseJsonObject(),
                TokenType.LeftBracket => ParseJsonArray(),
                _ => ParseJsonValue()
            };
        }

        private Expression ParseJsonObject()
        {
            var position = Current.Position;
            Expect(TokenType.LeftBrace);

            var properties = new Dictionary<string, Expression>();

            while (Current.Type != TokenType.RightBrace)
            {
                var key = Current.Type == TokenType.Identifier ? Current.Value : ExpectString();
                Advance();
                Expect(TokenType.Colon);
                var value = ParseJsonValue();

                properties[key] = value;

                if (Current.Type == TokenType.Comma)
                    Advance();
                else
                    break;
            }

            Expect(TokenType.RightBrace);
            return Expression.JsonValue(position, JsonValueType.Object, properties);
        }

        private Expression ParseJsonArray()
        {
            var position = Current.Position;
            Expect(TokenType.LeftBracket);

            var items = new List<Expression>();

            while (Current.Type != TokenType.RightBracket)
            {
                items.Add(ParseJsonValue());

                if (Current.Type == TokenType.Comma)
                    Advance();
                else
                    break;
            }

            Expect(TokenType.RightBracket);
            return Expression.JsonValue(position, JsonValueType.Array, items.ToArray());
        }

        private Expression ParseJsonValue()
        {
            var position = Current.Position;
            
            return Current.Type switch
            {
                TokenType.String => Expression.JsonValue(position, JsonValueType.String, ExpectString()),
                TokenType.Number => Expression.JsonValue(position, JsonValueType.Number, ExpectNumber()),
                TokenType.Boolean => Expression.JsonValue(position, JsonValueType.Boolean, ExpectBoolean()),
                TokenType.Null => Expression.JsonValue(position, JsonValueType.Null, ExpectNull()),
                TokenType.LeftBrace => ParseJsonObject(),
                TokenType.LeftBracket => ParseJsonArray(),
                _ => throw new ParseException($"Expected JSON value", Current.Position)
            };
        }

        private ReadOnlyMemory<Expression> ParseOptionalGroupByClause()
        {
            if (Current.Type != TokenType.Group)
                return ReadOnlyMemory<Expression>.Empty;

            Advance(); // consume "group"
            Expect(TokenType.By); // consume "by"

            return ParseFieldList();
        }

        private Expression? ParseOptionalHavingClause()
        {
            if (Current.Type != TokenType.Having)
                return null;

            Advance();
            return ParseOrExpression();
        }

        private ReadOnlyMemory<OrderByField> ParseOptionalOrderByClause()
        {
            if (Current.Type != TokenType.Order)
                return ReadOnlyMemory<OrderByField>.Empty;

            Advance(); // consume "order"
            Expect(TokenType.By); // consume "by"

            return ParseOrderByFieldList();
        }

        private ReadOnlyMemory<OrderByField> ParseOrderByFieldList()
        {
            var fields = new List<OrderByField>();

            do
            {
                var field = ParseFieldPath();
                var direction = SortDirection.Asc;

                if (Current.Type == TokenType.Asc || Current.Type == TokenType.Desc)
                {
                    direction = Current.Type == TokenType.Asc ? SortDirection.Asc : SortDirection.Desc;
                    Advance();
                }

                fields.Add(new OrderByField(field, direction));

                if (Current.Type == TokenType.Comma)
                    Advance();
                else
                    break;

            } while (true);

            return fields.ToArray();
        }

        private ReadOnlyMemory<Expression> ParseOptionalSelectClause()
        {
            if (Current.Type != TokenType.Select)
                return ReadOnlyMemory<Expression>.Empty;

            Advance();
            return ParseFieldList();
        }

        private ReadOnlyMemory<Expression> ParseFieldList()
        {
            var fields = new List<Expression>();

            do
            {
                fields.Add(ParseFieldPath());

                if (Current.Type == TokenType.Comma)
                    Advance();
                else
                    break;

            } while (true);

            return fields.ToArray();
        }

        private PaginationExpression? ParseOptionalPaginationClause()
        {
            if (Current.Type != TokenType.Page)
                return null;

            var position = Current.Position;
            Advance(); // "page"

            var page = int.Parse(ExpectNumber());
            Expect(TokenType.Of); // "of"
            Expect(TokenType.Size); // "size"
            var size = int.Parse(ExpectNumber());

            return new PaginationExpression(position, page, size);
        }

        // Helper Methods
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void Advance()
        {
            if (_position < _tokens.Length)
                _position++;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void Expect(TokenType expected)
        {
            if (Current.Type != expected)
            {
                throw new ParseException($"Expected {expected} but found '{Current.Value}'", Current.Position);
            }
            Advance();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private string ExpectIdentifier()
        {
            if (Current.Type != TokenType.Identifier)
            {
                throw new ParseException($"Expected identifier but found '{Current.Value}'", Current.Position);
            }
            var value = Current.Value;
            Advance();
            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private string ExpectString()
        {
            if (Current.Type != TokenType.String)
            {
                throw new ParseException($"Expected string but found '{Current.Value}'", Current.Position);
            }
            var value = Current.Value;
            Advance();
            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private string ExpectNumber()
        {
            if (Current.Type != TokenType.Number)
            {
                throw new ParseException($"Expected number but found '{Current.Value}'", Current.Position);
            }
            var value = Current.Value;
            Advance();
            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private string ExpectBoolean()
        {
            if (Current.Type != TokenType.Boolean)
            {
                throw new ParseException($"Expected boolean but found '{Current.Value}'", Current.Position);
            }
            var value = Current.Value;
            Advance();
            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private string ExpectNull()
        {
            if (Current.Type != TokenType.Null)
            {
                throw new ParseException($"Expected null but found '{Current.Value}'", Current.Position);
            }
            Advance();
            return "null";
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool IsComparisonOperator(TokenType type)
        {
            return type switch
            {
                TokenType.Equals or
                TokenType.NotEquals or
                TokenType.GreaterThan or
                TokenType.GreaterThanOrEqual or
                TokenType.LessThan or
                TokenType.LessThanOrEqual or
                TokenType.In or
                TokenType.Contains or
                TokenType.Any => true,
                _ => false
            };
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static ComparisonOperator TokenTypeToComparisonOperator(TokenType type)
        {
            return type switch
            {
                TokenType.Equals => ComparisonOperator.Equals,
                TokenType.NotEquals => ComparisonOperator.NotEquals,
                TokenType.GreaterThan => ComparisonOperator.GreaterThan,
                TokenType.GreaterThanOrEqual => ComparisonOperator.GreaterThanOrEqual,
                TokenType.LessThan => ComparisonOperator.LessThan,
                TokenType.LessThanOrEqual => ComparisonOperator.LessThanOrEqual,
                TokenType.In => ComparisonOperator.In,
                TokenType.Contains => ComparisonOperator.Contains,
                TokenType.Any => ComparisonOperator.Any,
                _ => throw new ArgumentException($"Not a comparison operator: {type}")
            };
        }
    }

    // Exception Types
    public class ParseException : Exception
    {
        public int Position { get; }

        public ParseException(string message, int position) : base($"{message} at position {position}")
        {
            Position = position;
        }

        public ParseException(string message, int position, Exception innerException) 
            : base($"{message} at position {position}", innerException)
        {
            Position = position;
        }
    }

    // Production-Ready Factory and Usage
    public static class SpoutDbParser
    {
        public static IStatement Parse(string input)
        {
            if (string.IsNullOrWhiteSpace(input))
                throw new ParseException("Empty input", 0);

            var tokenizer = new Tokenizer(input);
            var parser = new Parser(tokenizer.GetEnumerator());
            return parser.Parse();
        }

        public static bool TryParse(string input, out IStatement? statement, out ParseException? error)
        {
            try
            {
                statement = Parse(input);
                error = null;
                return true;
            }
            catch (ParseException ex)
            {
                statement = null;
                error = ex;
                return false;
            }
            catch (Exception ex)
            {
                statement = null;
                error = new ParseException($"Unexpected error: {ex.Message}", 0, ex);
                return false;
            }
        }

        // Performance testing helper
        public static IStatement ParseFromTokens(ReadOnlySpan<Token> tokens)
        {
            var parser = new Parser(tokens);
            return parser.Parse();
        }
    }

    // Binary Serialization Support (for Base256 storage)
    public interface IBinarySerializable
    {
        void WriteTo(Span<byte> buffer, ref int offset);
        int GetByteSize();
    }

    // Extension methods for AST visualization/debugging
    public static class AstExtensions
    {
        public static string ToDebugString(this IStatement statement)
        {
            return statement switch
            {
                QueryStatement query => $"Query({query.Operation}): {query.Table.Name}" +
                    (query.Joins.Length > 0 ? $" +{query.Joins.Length} joins" : "") +
                    (query.Where.HasValue ? " +where" : "") +
                    (query.Select.Length > 0 ? $" select({query.Select.Length})" : ""),
                
                UpsertStatement upsert => $"Upsert: {upsert.Table.Name}" +
                    (upsert.OnField != null ? $" on {upsert.OnField}" : ""),
                
                DeleteStatement delete => $"Delete: {delete.Table.Name}" +
                    (delete.Where.HasValue ? " +where" : ""),
                
                SchemaStatement schema => $"Schema({schema.Operation}): " +
                    (schema.TableName != null ? schema.TableName : "") +
                    (schema.ColumnName != null ? $".{schema.ColumnName}" : ""),
                
                BranchStatement branch => $"Branch({branch.Operation}): " +
                    (branch.BranchName ?? "") +
                    (branch.SourceBranch != null ? $" from {branch.SourceBranch}" : ""),
                
                AuthStatement auth => $"Auth({auth.Operation}): " +
                    (auth.TokenName ?? ""),
                
                MetaStatement meta => $"Meta({meta.Operation}): " +
                    (meta.Target ?? "") +
                    (meta.Source != null ? $" from {meta.Source}" : ""),
                
                _ => statement.GetType().Name
            };
        }

        public static string ToDebugString(this Expression expression)
        {
            return expression.Type switch
            {
                ExpressionType.FieldPath => string.Join(".", expression.As<ReadOnlyMemory<string>>().Span.ToArray()),
                ExpressionType.Binary => $"({expression.As<Expression.BinaryData>().Left.ToDebugString()} " +
                    $"{expression.As<Expression.BinaryData>().Operator} " +
                    $"{expression.As<Expression.BinaryData>().Right.ToDebugString()})",
                ExpressionType.Comparison => $"({expression.As<Expression.ComparisonData>().Left.ToDebugString()} " +
                    $"{expression.As<Expression.ComparisonData>().Operator} " +
                    $"{expression.As<Expression.ComparisonData>().Right.ToDebugString()})",
                ExpressionType.Literal => $"{expression.As<Expression.LiteralData>().LiteralType}:{expression.As<Expression.LiteralData>().Value}",
                ExpressionType.JsonValue => $"JSON({expression.As<Expression.JsonData>().ValueType})",
                _ => expression.Type.ToString()
            };
        }
    }
}

// Usage Examples and Testing
/*

// Basic Usage
var query = "get users where age > 25 and city = \"Berlin\" order by name asc";
var ast = SpoutDbParser.Parse(query);
Console.WriteLine(ast.ToDebugString());

// Complex Query with Joins
var complexQuery = @"
    get users 
        follow users.id -> orders.user_id as orders (left)
        follow orders.id -> order_items.order_id as items
        where orders.total > 1000 and users.city = ""Berlin""
        group by users.city
        having count > 10
        order by avg(orders.total) desc
        select users.name, users.email, orders.total
        page 1 of size 50";

if (SpoutDbParser.TryParse(complexQuery, out var complexAst, out var error))
{
    Console.WriteLine($"Parsed successfully: {complexAst.ToDebugString()}");
}
else
{
    Console.WriteLine($"Parse error: {error.Message}");
}

// Upsert with JSON
var upsert = "upsert users {name: \"John\", age: 30, profile: {theme: \"dark\", settings: [\"email\", \"sms\"]}} on email";
var upsertAst = SpoutDbParser.Parse(upsert);

// Schema Operations
var schema = "add column users.premium boolean";
var schemaAst = SpoutDbParser.Parse(schema);

// Branch Operations
var branch = "create branch feature/new-pricing from main";
var branchAst = SpoutDbParser.Parse(branch);

// Error Handling with Precise Position
if (!SpoutDbParser.TryParse("get users wher age > 25", out var result, out var parseError))
{
    Console.WriteLine($"Error at position {parseError.Position}: {parseError.Message}");
    // Output: "Error at position 10: Expected 'where' but found 'wher' at position 10"
}

// Performance Testing
var tokens = new Tokenizer("get users where age > 25").GetEnumerator();
var tokenArray = SpoutDbParser.CollectTokens(tokens);
var fastAst = SpoutDbParser.ParseFromTokens(tokenArray);

*/